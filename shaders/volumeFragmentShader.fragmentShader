#version 120

// all rays are given in camera coordinates
varying vec3 lightRay;
varying vec3 viewRay;
varying vec3 marchingRay;
varying vec3 texCoord;
varying vec3 positionCameraCoordinates;

uniform sampler3D volumeTexture;
uniform float id;


vec4 getColor(vec3 position, vec3 texCoords) {

	float scalar = texture3D(volumeTexture, texCoords).x;	// range [0,255] -> [0,1]
	vec4 color = vec4(scalar, scalar, scalar, scalar);

	return color;


	/*float LdotN = dot(L, N);

	// only calculate lighting if light source is not behind the surface
	if (LdotN >= 0) {
		vec3 R = 2 * LdotN * N - L;
		float RdotV = max(0, dot(R,V));

		// diffuse = kd * <L,N> * ld
		vec4 diffuseColor = color * LdotN * gl_LightSource[0].diffuse;

		// specular = ks * <R,V>^n * ls
		//vec4 specularColor = gl_FrontMaterial.specular * pow(RdotV, gl_FrontMaterial.shininess) * gl_LightSource[0].specular;

		//gl_FragData[0] = diffuseColor + specularColor + vec4(gl_Color.x / 5, gl_Color.y / 5, gl_Color.z / 5, 1);
		//float scalar = texture3D(volumeTexture, texCoord) / 255.0f;	// range [0,255]
		//gl_FragData[0] = (scalar, scalar, scalar, scalar);

	} else {
		//gl_FragData[0] = vec4(gl_Color.x / 5, gl_Color.y / 5, gl_Color.z / 5, 1);
		gl_FragData[0] = vec4(0,1,0,1);
	}*/
}

void main() {
	//vec3 N = normalize(normal);
	vec3 L = normalize(lightRay);
	vec3 V = normalize(viewRay);
	vec3 M = normalize(marchingRay);

	vec3 M_ModelCoordinates = vec3(gl_ModelViewMatrixInverse * vec4(M, 0));
	vec3 position = positionCameraCoordinates;
	vec3 texCoords = texCoord;
	

	float steps = 256.0f;
	M /= steps;
	
	M_ModelCoordinates /= steps;

	vec4 currentColor;
	vec4 aggregatedColor = vec4(0, 0, 0, 0);	

	// float i?

	//float x = texture3D(volumeTexture, texCoords).x;
	/*if (x > 1.0f) {	gl_FragData[0] = vec4(1,0,0,1); }
	else if (x < 0.01f) { gl_FragData[0] = vec4(0,1,0,1); }
	else { gl_FragData[0] = vec4(0,0,1,1); }*/
	//gl_FragData[0] = vec4(x,x,x,1);

	for (int i = 0; i < steps; i++) {
		position += M;
		texCoords += M_ModelCoordinates;
		
		currentColor = getColor(position, texCoords);
		if (aggregatedColor.a + currentColor.a <= 1) {
			aggregatedColor += currentColor.a * currentColor;
		} else if (aggregatedColor.a < 1) {
			aggregatedColor += (1 - aggregatedColor.a) * currentColor;
			break;
		} else {
			break;
		}
	}


	gl_FragData[0] = aggregatedColor;

	// id texture uses the RED channel only!
	gl_FragData[1] = vec4(id, 0, 0, 0);


}

