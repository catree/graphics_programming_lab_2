#version 120

// all rays are given in camera coordinates
varying vec3 lightRay;
varying vec3 viewRay;
varying vec3 marchingRay;
varying vec3 texCoord;
varying vec3 positionCameraCoordinates;

uniform sampler3D volumeTexture;
uniform sampler1D transferTexture;
uniform float id;
uniform vec3 aspectRatio;
uniform bool mip;



vec4 getColor(vec3 position, vec3 V, vec3 texCoords) {


	float scalar = texture3D(volumeTexture, texCoords).x;	
	vec4 color = texture1D(transferTexture, scalar + 0.5f / 256.0f);

	float stepWidth = 0.001;
	vec3 gradient = vec3(texture3D(volumeTexture, vec3(texCoords.s + stepWidth, texCoords.tp)).x
		 	   - texture3D(volumeTexture, vec3(texCoords.s - stepWidth, texCoords.tp)).x,
			     texture3D(volumeTexture, vec3(texCoords.s, texCoords.t + stepWidth, texCoords.p)).x
		 	   - texture3D(volumeTexture, vec3(texCoords.s, texCoords.t - stepWidth, texCoords.p)).x,
			     texture3D(volumeTexture, vec3(texCoords.st, texCoords.p + stepWidth)).x
		 	   - texture3D(volumeTexture, vec3(texCoords.st, texCoords.p - stepWidth)).x);
	vec3 N = normalize(gl_NormalMatrix * gradient);
	vec3 L = normalize(gl_LightSource[0].position.xyz - position);

	float LdotN = dot(L, N);

	// ambient term
	vec4 ambientColor = color * gl_LightSource[0].ambient;

	// only calculate lighting if light source is not behind the surface
	if (LdotN >= 0) {
		vec3 R = 2 * LdotN * N - L;
		float RdotV = max(0, dot(R,V));

		// diffuse = kd * <L,N> * ld
		vec4 diffuseColor = color * LdotN * gl_LightSource[0].diffuse;

		// specular = ks * <R,V>^n * ls
		vec4 specularColor = color * pow(RdotV, gl_FrontMaterial.shininess) * gl_LightSource[0].specular;

		return (ambientColor + diffuseColor + specularColor);

	} else {

		return ambientColor;
	}
}

void main() {
	vec3 V = normalize(viewRay);
	vec3 M = normalize(marchingRay);

	vec3 M_ModelCoordinates = vec3(gl_ModelViewMatrixInverse * vec4(M, 0));
	vec3 position = positionCameraCoordinates;
	vec3 coord = vec3(texCoord);
	

	int steps = 32;
	float steps_f = 32.0f;
	M /=  steps_f;

	//M_ModelCoordinates /= aspectRatio;
	//M_ModelCoordinates = normalize(M_ModelCoordinates);
	M_ModelCoordinates /=  steps_f;

	vec4 currentColor = vec4(0,0,0,0);
	vec4 aggregatedColor = vec4(0, 0, 0, 0);	

	bool opaque = false;
	float max = 0.0f;


	float scalar = texture3D(volumeTexture, coord).x;	
	vec4 color = texture1D(transferTexture, scalar + 0.5f / 256.0f);
	gl_FragData[0] = vec4(scalar, scalar, scalar, scalar);

	for (int i = 0; (i < steps) && (opaque == false) && (aggregatedColor.a < 0.98); i++) {

		
		if ((coord.x < 1.0f) && (coord.y < 1.0f) && (coord.z < 1.0f) &&
		    (coord.x > 0.0f) && (coord.y > 0.0f) && (coord.z > 0.0f)){



			if (mip) {
				float scalar = texture3D(volumeTexture, coord).x;
				if (scalar > max) { max = scalar; }
			} else {
				currentColor = getColor(position, V, coord);
				aggregatedColor += (1.0f - aggregatedColor.a) * currentColor * currentColor.a;
			}


		}

		position += M;
		coord += M_ModelCoordinates;

		
	}


	/*if (mip) {
		gl_FragData[0] = vec4(max, max, max, max);
	} else {
		gl_FragData[0] = aggregatedColor;
	}*/

	//gl_FragData[0] = getColor(position, coord);

	// id texture uses the RED channel only!
	gl_FragData[1] = vec4(id, 0, 0, 0);




}

