#version 400

layout (quads, equal_spacing) in;

in vec2 tTexCoord_Terrain[];
in vec3 tPosition_WS[];
in float tTesselation[];	// same for all 4 corner vertices
in float tMipLevel[];		// same for all 4 corner vertices
patch in int seam[4];

out vec2 fTexCoord_Terrain;
out vec3 fNormal_WS;
out vec3 fLightRay_WS;
out vec3 fViewRay_WS;
out float fHeight_01;
out vec3 debug;

//patch in float gl_TessLevelOuter[4];

uniform mat4 viewProjectionMatrix;

uniform vec3 camPosition_WS;
// 0 = position, 1 = ambient, 2 = diffuse, 3 = specular
uniform vec4 light0[4];

uniform float gridFraction;
uniform int verticalScaling;
uniform int nrQuads;

uniform sampler2D heightMap;


void main()
{
	// interpolate position
	vec3 pos1 = mix(tPosition_WS[0], tPosition_WS[1], gl_TessCoord.x);
	vec3 pos2 = mix(tPosition_WS[3], tPosition_WS[2], gl_TessCoord.x);
	vec3 pos_WS = mix(pos1, pos2, gl_TessCoord.y);

	// interpolate texture coordinate
	vec2 tex1 = mix(tTexCoord_Terrain[0], tTexCoord_Terrain[1], gl_TessCoord.x);
	vec2 tex2 = mix(tTexCoord_Terrain[3], tTexCoord_Terrain[2], gl_TessCoord.x);
	fTexCoord_Terrain = mix(tex1, tex2, gl_TessCoord.y);


	fHeight_01 = textureLod(heightMap, fTexCoord_Terrain, tMipLevel[0]).x;
	pos_WS += vec3(0, fHeight_01 * verticalScaling, 0);

	debug.x = tTesselation[0];
	debug.y = tMipLevel[0];

	debug.x = seam[0];
	debug.y = seam[1];
	debug.z = seam[2];
	debug.w = seam[3];

	//debug.x = round(log2(8));
	//debug.y = pos_WS.z / nrQuads;
	
	// compute normal of this vertex
	
	float stepSizeTex = 1 * gridFraction / nrQuads / tTesselation[0];
	float stepSizeWorld = 1 / tTesselation[0];

	float hRight_scaled = textureLod(heightMap, vec2(fTexCoord_Terrain.x + stepSizeTex, fTexCoord_Terrain.y), tMipLevel[0]).x * verticalScaling;
	float hTop_scaled = textureLod(heightMap, vec2(fTexCoord_Terrain.x, fTexCoord_Terrain.y + stepSizeTex), tMipLevel[0]).x * verticalScaling;

	vec3 toRight = vec3(stepSizeWorld, hRight_scaled - pos_WS.y, 0);
	vec3 toTop = vec3(0, hTop_scaled - pos_WS.y, stepSizeWorld);

	// careful: A x B in OpenGL is cross(B, A)
	fNormal_WS = normalize(cross(toTop, toRight));
	fLightRay_WS = light0[0].xyz - pos_WS;
	fViewRay_WS = camPosition_WS - pos_WS;

	gl_Position = viewProjectionMatrix * vec4(pos_WS, 1);
}
