#version 400

uniform int nrMaterials;
uniform vec4 light0[4];

uniform sampler2D material0;
uniform sampler2D material1;
uniform sampler2D material2;
uniform sampler2D material3;

in vec2 fTexCoord_Terrain;
in vec3 fNormal_WS;
in vec3 fLightRay_WS;
in vec3 fViewRay_WS;
in float fHeight_01;	// range [0, 1]
in vec3 debug;


float smoothstep(float edge0, float edge1, float x) {
    float t;  
    t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

void main()
{
	vec4 color0 = texture2D(material0, fTexCoord_Terrain * 8);
	vec4 color1 = texture2D(material1, fTexCoord_Terrain * 8);
	vec4 color2 = texture2D(material2, fTexCoord_Terrain * 8);
	vec4 color3 = texture2D(material3, fTexCoord_Terrain * 8);

	/* The closer the height of the vertex to range 0, the closer the result to 0.
	 * The closer the height to range 1, the closer the result to 1. 
	 * If the height is smaller than range 0 or greater than range 1, result is 
	 * clamped to 0/1 respectively. */
	// ranges: color0: [0.0, 0.004], color1: [0.0041, 0.025], color2: [0,0251, 0.04]
	// color3 is mixed in when the slope is not so steep, e.g. between [0.9, 1]

	vec4 color = vec4(1, 0, 0, 1);

	if (nrMaterials == 0) {
		color = vec4(0.5, 0.5, 0.5, 1); // grey
	} else if (nrMaterials == 1) {
		color = color0;
	} else if (nrMaterials == 2) {
		float btwnColor0_1 = smoothstep(0.02, 0.035, fHeight_01);
		color = mix(color0, color1, btwnColor0_1);
	} else if (nrMaterials == 3) {
		float btwnColor0_1 = smoothstep(0.015, 0.025, fHeight_01);
		color = mix(color0, color1, btwnColor0_1);

		float btwnColor01_2 = smoothstep(0.035, 0.040, fHeight_01);
		color = mix(color, color2, btwnColor01_2);
	} else if (nrMaterials >=4 ) {

		float slope = normalize(fNormal_WS).y;

		float btwnColor0_1 = smoothstep(0.015, 0.025, fHeight_01);
		color = mix(color0, color1, btwnColor0_1);

		float btwnColor01_2 = smoothstep(0.035, 0.040, fHeight_01);
		color = mix(color, color2, btwnColor01_2);

		float btwnColor012_3 = smoothstep(0.9, 1, slope) / 3;
		color = mix(color, color3, btwnColor012_3);
	}
	

	vec3 N = normalize(fNormal_WS);
	vec3 L = normalize(fLightRay_WS);
	vec3 V = normalize(fViewRay_WS);

	float LdotN = dot(L, N);
	vec4 outputColor = light0[1] * color;
	//vec4 outputColor = color0;

	// only calculate lighting if light source is not behind the surface
	if (LdotN >= 0) {
		// R = reflection ray
		vec3 R = 2 * LdotN * N - L;
		float RdotV = max(0, dot(R,V));

		// diffuse = kd * <L,N> * ld
		vec4 diffuseColor = color * LdotN * light0[2];

		// specular = ks * <R,V>^n * ls
		vec4 specularColor = pow(RdotV, 240) * light0[3];

		outputColor += diffuseColor + specularColor;
	
	} 
	
	gl_FragData[0] = outputColor;

	vec3 c;
	if (debug.y <= 0) { c = vec3(1, 0, 0); }	// red
	else if (debug.y <= 1) { c = vec3(0, 1, 0); }	// green
	else if (debug.y <= 2) { c = vec3(0, 0, 1); }	// blue
	else if (debug.y <= 3) { c = vec3(1, 1, 0); } 	// yellow
	else if (debug.y <= 4) { c = vec3(0, 1, 1); }	// cyan
	else if (debug.y <= 5) { c = vec3(1, 0, 1); }	// magenta
	else if (debug.y <= 6) { c = vec3(1, 1, 1); }	// white
	else if (debug.y <= 7) { c = vec3(0, 0, 0); }	// black
	else if (debug.y <= 8) { c = vec3(0.5, 0, 0); }	// dark red
	else if (debug.y <= 9) { c = vec3(0, 0.5, 0); }	// dark green
	else if (debug.y <= 10) { c = vec3(0, 0, 0.5); }	// dark blue
	else if (debug.y <= 11) { c = vec3(0.5, 0.5, 0); }	// dark yellow
	else if (debug.y <= 12) { c = vec3(0, 0.5, 0.5); }	// dark cyan
	else if (debug.y <= 13) { c = vec3(0.5, 0, 0.5); }	// dark magenta
	else { c = vec3(0.5, 0.5, 0.5); }	// grey

	


/*	if (debug.y <= 1) { c = vec3(1, 0, 0); }	// red
	else if (debug.y <= 2) { c = vec3(0, 1, 0); }	// green
	else if (debug.y <= 4) { c = vec3(0, 0, 1); }	// blue
	else if (debug.y <= 8) { c = vec3(1, 1, 0); } 	// yellow
	else if (debug.y <= 16) { c = vec3(0, 1, 1); }	// cyan
	else if (debug.y <= 32) { c = vec3(1, 0, 1); }	// magenta
	else if (debug.y <= 64) { c = vec3(1, 1, 1); }	// white
*/
	gl_FragData[0] = vec4(debug.x, debug.y, debug.z, debug.w);

	//gl_FragData[0] = vec4(modf(-1.5, bla) + 1, 0, 0, 1);

}
